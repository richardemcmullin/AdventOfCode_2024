// Advent of Code 2024 - Day 11 Solution (RM)
// Author: RM + AI (ChatGPT-4.1)

package day11;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import aoc.AdventOfCodeSolver;

public class Day11_RM extends AdventOfCodeSolver {

    class Stone {

        long value;

        List<Stone> childStones = null;

        Map<Integer, Long> stonesAtIterationCache = new HashMap<>();

        Stone(long value) {
            this.value = value;
        }

        // Get the number of stones generated by this stone at a specific iteration
        // Each stone will generate the same pattern of sub-stones over time.
        long getStoneCountAtIteration(int iteration) {

            // Base case: at iteration 0, each stone is just itself
            if (iteration < 1) {
                return 1;
            }

            // If this iteration has already been calculated, then retrieve
            // it from the iteration cache
            if (stonesAtIterationCache.containsKey(iteration)) {

                return stonesAtIterationCache.get(iteration);

            } else {

                // If the children have not yet been calculated, then
                // determine the set of children stones based on the iteration logic
                if (childStones == null) {
                    calcChildStones();
                }

                // For each of the children stones, calculate the number of sub-stones
                // they will generate with one fewer iterations.
                long stoneCount = 0;

                for (Stone child : childStones) {
                    stoneCount += child.getStoneCountAtIteration(iteration - 1);
                }

                // Cache the result so that subsequent lookups of this stone with
                // this number of iterations can just return the result instead
                // of re-calculating the result
                stonesAtIterationCache.put(iteration, stoneCount);

                return stoneCount;
            }
        }

        private void calcChildStones() {

            // Calculate the child stones that will be generated from this
            // stone on the first iteration using the iteration rules in the puzzle
            childStones = new ArrayList<>();

            String valueString = String.valueOf(value);

            // If the value string is even in digits, then the stone splits into two child
            // stones
            if (valueString.length() % 2 == 0) {
                int mid = valueString.length() / 2;
                long leftValue = Integer.parseInt(valueString.substring(0, mid));
                long rightValue = Integer.parseInt(valueString.substring(mid));

                // Look for the child stones in the global cache
                // If the child stone value has not yet been cached, then
                // create the stone.
                Stone leftStone = stoneValueMap.get(leftValue);
                if (leftStone == null) {
                    leftStone = new Stone(leftValue);
                    stoneValueMap.put(leftValue, leftStone);
                }
                Stone rightStone = stoneValueMap.get(rightValue);
                if (rightStone == null) {
                    rightStone = new Stone(rightValue);
                    stoneValueMap.put(rightValue, rightStone);
                }

                childStones.add(leftStone);
                childStones.add(rightStone);

            } else {

                // A single sub-stone will be generated from this stone with
                // the supplied value.
                // Zeros become ones
                long nextStoneValue = 1;

                // All non-zero values are multiplied by 2024.
                if (value > 0) {
                    nextStoneValue = value * 2024;
                }

                // Find the stone in the global cache or create it.
                Stone nextStone = stoneValueMap.get(nextStoneValue);
                if (nextStone == null) {
                    nextStone = new Stone(nextStoneValue);
                    stoneValueMap.put(nextStoneValue, nextStone);
                }

                childStones.add(nextStone);
            }
        }
    }

    // Global cache of all stones by value.
    Map<Long, Stone> stoneValueMap = new HashMap<>();
    List<Stone> inputStones = new ArrayList<>();

    @Override
    protected void parseInput() {

        String[] stoneValueStrings = inputLines.get(0).trim().split(" ");

        for (String stoneValue : stoneValueStrings) {

            long value = Long.parseLong(stoneValue.trim());

            // Look for the same stone value in the input
            Stone stone = stoneValueMap.get(value);

            if (stone == null) {
                stone = new Stone(value);
                stoneValueMap.put(value, stone);
            }
            inputStones.add(stone);
        }
    }

    @Override
    public Object solvePart1() {

        long stoneCount = 0;

        for (Stone stone : inputStones) {
            // Calculate the number of stones at iteration 25
            stoneCount += stone.getStoneCountAtIteration(25);
        }

        return stoneCount;
    }

    @Override
    public Object solvePart2() {

        long stoneCount = 0;

        for (Stone stone : inputStones) {
            // Calculate the number of stones at iteration 75
            // NOTE: This second part uses any cached values generated in part 1.
            stoneCount += stone.getStoneCountAtIteration(75);
        }

        return stoneCount;
    }

    public static void main(String[] args) {
        new Day11_RM().run();
    }
}
